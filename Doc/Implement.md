# 实现思路

# 闭包
寄存器跟随函数体

函数调用时, 寄存器入栈保存

闭包引用整个寄存器体及索引


# 寄存器分配规则
全局Scope分配在每个Package的全局寄存器

函数及以下的寄存器分配在Local寄存器上

每个函数体有记录最大的寄存器用量, 调用函数时, 寄存器保留调用函数的最大寄存器分配量

for, while等函数体内的其他block scope的寄存器在函数体寄存器上分配, 同层覆盖

# 返回值平衡

多级调用时, 根据上级AST关系, 可以判断出是否需要保留数据栈(不清空,不调整)

在碰到函数有接收返回值时, 父级为AssignStmt

计算接收返回值数量传给CALL

在运行期根据实际返回数量与接收数量进行栈平衡

# Symbol与寄存器

函数声明, import名是Symbol, 但不分配寄存器

只有 变量, 形式参数的需要分配寄存器


# 包寄存器和Local寄存器

每个包有全局有全局变量, 这些变量通过包寄存器进行内存分配和操作

Local寄存器整个虚拟机只有1份, 所有包共用

# Package

函数注册时, 将函数注册到方法区

# 外部类注册

通过在方法特性标示区分在语言中的表现方法

- 类静态函数->包函数

- 类成员函数->类成员函数

函数入口只支持静态函数

类成员函数调用时, 第一个参数为self

