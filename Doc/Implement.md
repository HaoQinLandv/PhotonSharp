# 实现思路

# 闭包
寄存器跟随函数体

函数调用时, 寄存器入栈保存

闭包引用整个寄存器体及索引


# 寄存器分配规则
全局Scope分配在每个Package的全局寄存器

函数及以下的寄存器分配在Local寄存器上

每个函数体有记录最大的寄存器用量, 调用函数时, 寄存器保留调用函数的最大寄存器分配量

for, while等函数体内的其他block scope的寄存器在函数体寄存器上分配, 同层覆盖

# 返回值平衡

多级调用时, 根据上级AST关系, 可以判断出是否需要保留数据栈(不清空,不调整)

在碰到函数有接收返回值时, 父级为AssignStmt

计算接收返回值数量传给CALL

在运行期根据实际返回数量与接收数量进行栈平衡

# Symbol与寄存器

函数声明, import名是Symbol, 但不分配寄存器

只有 变量, 形式参数的需要分配寄存器


# 包寄存器和Local寄存器

每个包有全局有全局变量, 这些变量通过包寄存器进行内存分配和操作

Local寄存器整个虚拟机只有1份, 所有包共用

# Package

函数注册时, 将函数注册到方法区

# 外部类注册

通过在方法特性标示区分在语言中的表现方法

- 类静态函数->包函数

- 类成员函数->类成员函数

函数入口只支持静态函数

类成员函数调用时, 第一个参数为self

# 层次
一个Executable包含N个包, 1个ScopeManager
每个包有N个SourceFile和对应的FileNode
FileNode间共享ScopeManager的Scope信息


# init和main
lua的每个文件的全局部分=init/main

但是init和main可以让代码的声明和运行清晰

# hot patch与import
lua可以做hot patch. 前一个文件跑着的时候, vm没释放时可以直接再次加载另外一个文件并混合前面的vm状态继续执行

pho不支持这个特性. 但是可以做函数的edit & continue技术